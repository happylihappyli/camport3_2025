import os
import sys
from os.path import join, abspath, exists
from SCons.Script import *
import time
import re
import os

# 全局编译统计信息
build_start_time = time.time()
compile_errors = 0
compile_warnings = 0

# 自定义构建器，用于捕获编译错误
import subprocess
import sys
import os

def build_with_error_tracking(env):
    # 保存原始的Program方法
    original_program = env.Program
    
    # 创建一个函数来执行构建命令并捕获输出
    def capture_build_output(cmd):
        global compile_errors, compile_warnings
        
        try:
            # 执行命令并捕获输出
            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            output = result.stdout
            
            # 解析输出中的错误和警告
            errors = re.findall(r'error|致命错误', output, re.IGNORECASE)
            warnings = re.findall(r'warning', output, re.IGNORECASE)
            
            compile_errors += len(errors)
            compile_warnings += len(warnings)
            
            return result.returncode, output
        except Exception as e:
            compile_errors += 1
            return 1, f"Error executing command: {e}"
    
    # 创建一个更简单的包装器来跟踪构建状态
    def wrapped_program(*args, **kwargs):
        global compile_errors
        try:
            result = original_program(*args, **kwargs)
            return result
        except Exception as e:
            compile_errors += 1
            print(f"Program build error: {e}")
            return None
    
    # 替换Program方法
    env.Program = wrapped_program
    
    return env

# 在构建开始前清除之前的错误计数
def reset_compile_stats():
    global compile_errors, compile_warnings
    compile_errors = 0
    compile_warnings = 0

# 初始化编译统计
reset_compile_stats()

# 输出编译总结
def print_compile_summary():
    global compile_errors, compile_warnings
    build_end_time = time.time()
    elapsed_time = build_end_time - build_start_time
    
    print("\n" + "=" * 80)
    print("                    Camport3 编译总结                    ")
    print("=" * 80)
    print(f"编译耗时: {elapsed_time:.2f} 秒")
    
    # 检查是否有成功编译的可执行文件
    bin_dir = os.path.abspath('bin')
    sample_v1_exes = []
    sample_v2_exes = []
    if os.path.exists(bin_dir):
        executables = [f for f in os.listdir(bin_dir) if f.endswith('.exe')]
        sample_v1_exes = [f for f in executables if not f.endswith('_v2.exe')]
        sample_v2_exes = [f for f in executables if f.endswith('_v2.exe')]
        
        print(f"\n成功编译的可执行文件:")
        print(f"Sample_v1 可执行文件数量: {len(sample_v1_exes)}")
        for exe in sample_v1_exes:
            print(f"  - {exe}")
            
        print(f"Sample_v2 可执行文件数量: {len(sample_v2_exes)}")
        for exe in sample_v2_exes:  # 只显示前5个sample_v2可执行文件
            print(f"  - {exe}")
    
    # 尝试直接检测是否有编译错误
    try:
        # 检查最近的构建日志文件
        if os.path.exists('.sconsign.dblite'):
            # 使用scons -n命令查看构建过程，这不会实际构建，但可以显示命令
            try:
                build_log = subprocess.check_output(['scons', '-n'], stderr=subprocess.STDOUT, universal_newlines=True)
                errors_in_log = re.findall(r'error|致命错误', build_log, re.IGNORECASE)
                if errors_in_log:
                    compile_errors += len(errors_in_log)
            except:
                pass
        
        # 检查系统环境中是否有SCONS_ERROR变量
        if 'SCONS_ERROR' in os.environ:
            try:
                compile_errors += int(os.environ.get('SCONS_ERROR', '0'))
            except:
                pass
            
    except Exception as e:
        print(f"Error checking build status: {e}")
    
    # 显示编译错误和警告统计
    print(f"\n编译统计:")
    print(f"编译错误数量: {compile_errors}")
    print(f"编译警告数量: {compile_warnings}")
    
    # 判断编译状态 - 更直接的方法是检查是否有编译错误记录
    success = compile_errors == 0
    
    print(f"编译状态: {'成功' if success else '失败'}")
    
    print("=" * 80)
    print("编译总结已完成。")
    print("=" * 80)

# ==============================================================================
# Camport3项目构建配置总结
# ==============================================================================
# 项目概述：
#   - 包含两个版本的示例程序：sample_v1（基础示例）和sample_v2（更新版示例）
#   - 统一输出目录：所有可执行文件都生成到bin目录
#   - 主要依赖：tycam库、common_lib（项目内部公共库）
#   - 注意事项：当前配置不包含OpenCV依赖，使用非OpenCV实现路径
#   - 支持平台：当前专注于Windows x64平台
# ==============================================================================

print("Using simplified SConstruct for troubleshooting OpenCV linking issues")

# 设置构建选项
opts = Variables()
opts.Add('OPENCV_DIR', 'Path to OpenCV installation directory', 'D:\\Code\\opencv')

# 构建选项
opts.Add('BUILD_SAMPLE_V1', 'Enable sample v1 build', '1')
opts.Add('BUILD_SAMPLE_V2', 'Enable sample v2 build', '1')

# 创建统一的bin目录，用于存放所有可执行文件
bin_dir = os.path.abspath('bin')
if not os.path.exists(bin_dir):
    os.makedirs(bin_dir)    # 创建bin目录
    print(f"Created bin directory: {bin_dir}")

# 创建obj目录，用于存放所有目标文件
obj_dir = os.path.abspath('obj')
# 按照用户要求，将obj文件放到E:\github\camport3_2025\sample\obj目录
obj_dir = "E:\\github\\camport3_2025\\sample\\obj"
if not os.path.exists(obj_dir):
    os.makedirs(obj_dir)
    print(f"Created obj directory: {obj_dir}")

env = Environment(variables=opts)

# 为了防止不同示例的obj文件命名冲突，我们使用不同的子目录
# 这里我们不直接设置OBJPREFIX，而是在每个子环境中设置不同的路径
# 主环境的obj文件直接放在obj_dir下

# 设置基本路径
LIB_ROOT_PATH = abspath('../lib/win/hostapp/')
INCLUDE_PATH = abspath('../include/')
COMMON_DIR = abspath('./common/')

# 平台特定配置 - 只关注Windows平台
if sys.platform == 'win32':
    # Windows配置
    env.Append(CPPPATH=[INCLUDE_PATH, COMMON_DIR])
    
    # 定义WIN32宏
    env.Append(CPPDEFINES=['WIN32'])
    
    # 添加编译选项
    env.Append(CXXFLAGS=['/EHsc'])

    # 架构选择
    lib_arch = 'x64'  # 使用64位架构
    lib_path = join(LIB_ROOT_PATH, lib_arch)
    env.Append(LIBPATH=[lib_path])
    
    # 添加基本库
    env.Append(LIBS=['tycam'])
    
    # 配置OpenCV依赖
    opencv_dir = env.get('OPENCV_DIR', '')
    if opencv_dir and os.path.exists(opencv_dir):
        print(f"Building with OpenCV support from {opencv_dir}")
        # 添加OpenCV头文件路径
        env.Append(CPPPATH=[join(opencv_dir, 'build', 'include')])
        # 添加OpenCV库路径
        env.Append(LIBPATH=[join(opencv_dir, 'build', 'x64', 'vc15', 'lib')])
        # 添加OpenCV库文件（只添加Release版本）
        env.Append(LIBS=['opencv_world347'])
        # 确保OpenCV库在链接顺序中的位置正确
        env.Prepend(LIBS=['opencv_world347'])
        # 定义OPENCV_DEPENDENCIES宏，启用OpenCV相关代码
        env.Append(CPPDEFINES=['OPENCV_DEPENDENCIES'])
    else:
        print("Building without OpenCV dependency")

# 启用编译错误和警告跟踪
env = build_with_error_tracking(env)

# 定义common源文件
common_sources = [
    join(COMMON_DIR, 'MatViewer.cpp'),
    join(COMMON_DIR, 'TYThread.cpp'),
    join(COMMON_DIR, 'crc32.cpp'),
    join(COMMON_DIR, 'json11.cpp'),
    join(COMMON_DIR, 'ParametersParse.cpp'),
    join(COMMON_DIR, 'huffman.cpp'),
    join(COMMON_DIR, 'ImageSpeckleFilter.cpp'),
    join(COMMON_DIR, 'DepthInpainter.cpp'),
    join(COMMON_DIR, 'funny_resize.cpp'),
]

# 为common_lib创建专用环境，不包含任何OpenCV依赖
common_env = env.Clone()
# 确保common_lib的obj文件也放到指定目录
common_env['OBJPREFIX'] = os.path.join(obj_dir, 'common_')

# 确保common_lib不依赖任何OpenCV库
common_lib = common_env.Library('common_lib', common_sources)

# 明确将common_lib添加到环境的LIBS中，确保链接时可以找到
env.Append(LIBS=['common_lib'])

# 先构建common_lib，再构建示例程序
export_libs = {'env': env, 'bin_dir': bin_dir, 'common_lib': common_lib}
SConscript('sample_v1/SConscript', exports=export_libs)

# 编译sample_v2示例目录 - 暂时禁用
if env.get('BUILD_SAMPLE_V2', '0') == '1':
    print("开始编译sample_v2目录")
    # 为sample_v2创建专用环境
    sample_v2_env = env.Clone()
    # 确保sample_v2_env的obj文件也放到指定目录，使用前缀避免冲突
    sample_v2_env['OBJPREFIX'] = os.path.join(obj_dir, 'sample_v2_')
    # 确保sample_v2_env包含common_lib
    if 'common_lib' not in sample_v2_env['LIBS']:
        sample_v2_env.Append(LIBS=['common_lib'])

    if opencv_dir and os.path.exists(opencv_dir):
        # 如果OpenCV路径有效，设置BUILD_SAMPLE_V2_WITH_OPENCV标志为1启用OpenCV支持
        print("启用sample_v2的OpenCV支持")
        sample_v2_env['BUILD_SAMPLE_V2_WITH_OPENCV'] = '1'
    else:
        print("sample_v2不使用OpenCV")

    # 传递克隆的环境和common_lib
    SConscript('sample_v2/sample/SConscript', exports={'env': sample_v2_env, 'bin_dir': bin_dir, 'common_lib': common_lib})
else:
    print("sample_v2构建已禁用")

print("Simplified SConstruct configuration completed.")
print("end compile")
# # 在SCons构建结束时调用编译总结函数
# import atexit
# atexit.register(print_compile_summary)

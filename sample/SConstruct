import os
import sys
from os.path import join, abspath, exists
from SCons.Script import *
import time
import re
import subprocess

# 全局编译统计信息
build_start_time = time.time()
compile_errors = 0
compile_warnings = 0

# ==============================================================================
# Camport3项目构建配置总结
# ==============================================================================
# 项目概述：
#   - 包含两个版本的示例程序：sample_v1（基础示例）和sample_v2（更新版示例）
#   - 统一输出目录：所有可执行文件都生成到bin目录
#   - 主要依赖：tycam库、common_lib（项目内部公共库）
#   - 注意事项：当前配置不包含OpenCV依赖，使用非OpenCV实现路径
#   - 支持平台：当前专注于Windows x64平台
#   - FastCamera类实现：从BV_WorkSpace项目引用并编译
# ==============================================================================

print("使用简化版SConstruct配置文件解决链接问题")

# 设置构建选项
opts = Variables()
opts.Add('OPENCV_DIR', 'Path to OpenCV installation directory', 'D:\\Code\\opencv')

# 构建选项
opts.Add('BUILD_SAMPLE_V1', 'Enable sample v1 build', '1')
opts.Add('BUILD_SAMPLE_V2', 'Enable sample v2 build', '1')

# 创建统一的bin目录，用于存放所有可执行文件
bin_dir = os.path.abspath('bin')
if not os.path.exists(bin_dir):
    os.makedirs(bin_dir)    
    print(f"Created bin directory: {bin_dir}")

# 创建obj目录，用于存放所有目标文件
obj_dir = "E:\\github\\camport3_2025\\sample\\obj"
if not os.path.exists(obj_dir):
    os.makedirs(obj_dir)
    print(f"Created obj directory: {obj_dir}")

# 配置使用Clang编译器
env = Environment(variables=opts)

# 设置Clang编译器路径 - 使用系统安装的Clang
if sys.platform == 'win32':
    # 使用系统安装的clang-cl
    clang_cl_path = r"C:\Program Files\LLVM\bin\clang-cl.exe"
    if os.path.exists(clang_cl_path):
        env['CC'] = '"' + clang_cl_path + '"'
        env['CXX'] = '"' + clang_cl_path + '"'
        env['AR'] = r'"C:\Program Files\LLVM\bin\llvm-lib.exe"'
        env['LINK'] = r'"C:\Program Files\LLVM\bin\lld-link.exe"'
        
        # Clang编译选项
        env.Append(CXXFLAGS=['/std:c++17', '/Wall'])
        env.Append(CPPDEFINES=['_WIN32'])
        
        print(f"使用系统Clang编译器: {clang_cl_path}")
    else:
        # 尝试使用LLVM目录下的clang
        llvm_clang_path = r"C:\Program Files (x86)\LLVM\bin\clang-cl.exe"
        if os.path.exists(llvm_clang_path):
            env['CC'] = '"' + llvm_clang_path + '"'
            env['CXX'] = '"' + llvm_clang_path + '"'
            env['AR'] = r'"C:\Program Files (x86)\LLVM\bin\llvm-lib.exe"'
            env['LINK'] = r'"C:\\Program Files (x86)\\LLVM\\bin\\lld-link.exe"'
            
            # Clang编译选项
            env.Append(CXXFLAGS=['/std:c++17', '/Wall'])
            env.Append(CPPDEFINES=['_WIN32'])
            
            print(f"使用系统LLVM Clang编译器: {llvm_clang_path}")
        else:
            print("警告: 未找到clang-cl.exe，使用MSVC编译器但配置Clang兼容选项")
            # 使用MSVC但配置为Clang兼容模式
            env.Append(CXXFLAGS=['/std:c++17'])

# 设置基本路径
LIB_ROOT_PATH = 'E:/github/BV_WorkSpace'  
INCLUDE_PATH = abspath('../include/')
COMMON_DIR = abspath('./common/')

# Windows配置
if sys.platform == 'win32':
    # 基本路径配置 - 只使用camport3的include，避免重复包含BV_WorkSpace的头文件
    env.Append(CPPPATH=[INCLUDE_PATH, COMMON_DIR])
    env.Append(CPPDEFINES=['WIN32'])
    # 移除MSVC特有的/EHsc选项，使用Clang兼容选项
    # env.Append(CXXFLAGS=['/EHsc'])

    # 不需要freeglut include目录（使用简化版本）

    # 库路径配置
    lib_arch = 'x64'  # 使用64位架构
    lib_paths = [
        'E:/github/BV_WorkSpace/bin',    # BV_WorkSpace的bin目录（包含tycam.lib）
        'E:/github/BV_WorkSpace/lib',    # BV_WorkSpace的lib目录
        join(LIB_ROOT_PATH, lib_arch),  # 原始路径
        abspath('./'),                 # 当前目录（包含common_lib.lib）
        abspath('./bin'),              # bin目录（包含tycam.lib）
    ]
    env.Append(LIBPATH=lib_paths)
    
    # 添加基本库
    env.Append(LIBS=['tycam'])
    
    # 添加OpenGL相关库和Windows API库
    env.Append(LIBS=['opengl32', 'glu32', 'user32', 'gdi32', 'kernel32'])
    
    # Clang链接选项 - Windows下使用lld-link
    env.Append(LINKFLAGS=['/MANIFEST'])

# 定义cloud_viewer源文件 - 使用简化版本，不依赖freeglut
cloud_viewer_sources = [
    join('./cloud_viewer', 'cloud_viewer_simple.cpp'),
]

# 构建cloud_viewer库
cloud_viewer_env = env.Clone()
cloud_viewer_env['OBJPREFIX'] = os.path.join(obj_dir, 'cloud_viewer_')
cloud_viewer_lib = cloud_viewer_env.Library('cloud_viewer', cloud_viewer_sources)
env.Append(LIBS=['cloud_viewer'])

# 定义common源文件
common_sources = [
    join(COMMON_DIR, 'MatViewer.cpp'),
    join(COMMON_DIR, 'TYThread.cpp'),
    join(COMMON_DIR, 'crc32.cpp'),
    join(COMMON_DIR, 'json11.cpp'),
    join(COMMON_DIR, 'ParametersParse.cpp'),
    join(COMMON_DIR, 'huffman.cpp'),
    join(COMMON_DIR, 'ImageSpeckleFilter.cpp'),
    join(COMMON_DIR, 'DepthInpainter.cpp'),
    join(COMMON_DIR, 'funny_resize.cpp'),
]

# 构建common_lib
common_env = env.Clone()
common_env['OBJPREFIX'] = os.path.join(obj_dir, 'common_')
common_lib = common_env.Library('common_lib', common_sources)
env.Append(LIBS=['common_lib'])

# 使用修复后的FastCamera实现
print("使用修复后的FastCamera实现（移除异常处理）...")
fastcamera_source = 'E:/github/camport3_2025/sample/device_fix.cpp'
fastcamera_header = 'E:/github/camport3_2025/sample/device_fix.hpp'

# 检查修复后的FastCamera源文件是否存在
if os.path.exists(fastcamera_source) and os.path.exists(fastcamera_header):
    print("找到修复后的FastCamera实现文件，添加到构建...")
    
    # 编译修复后的FastCamera源文件为obj文件
    fastcamera_env = env.Clone()
    fastcamera_include_path = os.path.dirname(fastcamera_header)
    fastcamera_env.Append(CPPPATH=[fastcamera_include_path])
    
    fastcamera_obj = fastcamera_env.Object(source=fastcamera_source, OBJPREFIX=os.path.join(obj_dir, 'fastcamera_'))
    
    print(f"修复后的FastCamera source: {fastcamera_source}")
    print(f"修复后的FastCamera header: {fastcamera_header}")
    print(f"修复后的FastCamera object: {fastcamera_obj}")
    
    # 将修复后的FastCamera对象添加到环境变量中，供后续的链接使用
    env['FASTERCAMERA_OBJ'] = fastcamera_obj
else:
    print(f"警告: 找不到修复后的FastCamera实现文件，尝试使用原始文件...")
    # 如果修复文件不存在，回退到原始文件
    original_source = 'E:/github/BV_WorkSpace/thirdparty/ty_sdk/src/Device.cpp'
    original_header = 'E:/github/BV_WorkSpace/thirdparty/ty_sdk/include/Device.hpp'
    
    if os.path.exists(original_source) and os.path.exists(original_header):
        print("使用原始FastCamera实现文件...")
        
        fastcamera_env = env.Clone()
        fastcamera_include_path = os.path.dirname(original_header)
        fastcamera_env.Append(CPPPATH=[fastcamera_include_path])
        
        fastcamera_obj = fastcamera_env.Object(source=original_source, OBJPREFIX=os.path.join(obj_dir, 'fastcamera_'))
        
        env['FASTERCAMERA_OBJ'] = fastcamera_obj
    else:
        print(f"错误: 找不到任何FastCamera实现文件!")
        env['FASTERCAMERA_OBJ'] = None

# 配置OpenCV依赖 - 完全禁用OpenCV
print("完全禁用OpenCV依赖进行构建")
# 确保不包含任何OpenCV相关路径和库
if 'opencv_world347' in env.get('LIBS', []):
    while 'opencv_world347' in env['LIBS']:
        env['LIBS'].remove('opencv_world347')
    print("移除opencv_world347库")

# 清理可能的OpenCV路径
env['CPPPATH'] = [p for p in env.get('CPPPATH', []) if 'opencv' not in p.lower()]
env['LIBPATH'] = [p for p in env.get('LIBPATH', []) if 'opencv' not in p.lower()]

# 确保不定义OpenCV相关宏
if 'OPENCV_DEPENDENCIES' in env.get('CPPDEFINES', []):
    if isinstance(env['CPPDEFINES'], list):
        env['CPPDEFINES'].remove('OPENCV_DEPENDENCIES')
    elif isinstance(env['CPPDEFINES'], dict):
        del env['CPPDEFINES']['OPENCV_DEPENDENCIES']

print("OpenCV依赖已完全禁用")

# 构建示例程序
print("构建示例程序...")

# 构建sample_v1
build_sample_v1 = env.get('BUILD_SAMPLE_V1', '1')
if build_sample_v1 == '1':
    print("Building sample_v1...")
    SConscript('sample_v1/SConscript', exports={'env': env, 'bin_dir': bin_dir, 'common_lib': common_lib})

# 构建sample_v2
build_sample_v2 = env.get('BUILD_SAMPLE_V2', '1')
if build_sample_v2 == '1':
    print("Building sample_v2...")
    SConscript('sample_v2/sample/SConscript', exports={'env': env, 'bin_dir': bin_dir, 'common_lib': common_lib})

print("SConstruct配置完成。")
print("编译结束")

build_end_time = time.time()
elapsed_time = build_end_time - build_start_time
print(f"编译总耗时: {elapsed_time:.2f} 秒")